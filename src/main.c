// 030F4P6

#include <math.h>
#include "stm32f0xx.h"
#include "main.h"

unsigned int general_flags_g;
unsigned short measurements_period_counter_g;
unsigned int i2c1_isr_register_g;
SHT21_Measurement_TypeDef sht21_measurements_queue_g[2];
unsigned char sht21_measurements_queue_index_g;
unsigned short sht21_measurement_countdown_counter_g;
char *result_to_send_g;

volatile float temperature_g;
volatile float humidity_g;
unsigned short adc_dma_converted_data_g;

void DMA1_Channel2_3_IRQHandler() {
   DMA_ClearITPendingBit(DMA1_IT_TC2);
   set_flag(&general_flags_g, USART_TRANSFER_COMPLETE_FLAG);
}

void DMA1_Channel1_IRQHandler() {
   if (DMA_GetITStatus(DMA1_IT_TC1)) {
      DMA_ClearITPendingBit(DMA1_IT_TC1);
   }
}

/*void ADC1_COMP_IRQHandler() {
   ADC_ClearITPendingBit(ADC1, ADC_IT_EOC);
}*/

void TIM14_IRQHandler() {
   TIM_ClearITPendingBit(TIM14, TIM_IT_Update);

   measurements_period_counter_g++;
}

void TIM3_IRQHandler() {
   TIM_ClearITPendingBit(TIM3, TIM_IT_Update);

   if (sht21_measurement_countdown_counter_g) {
      sht21_measurement_countdown_counter_g--;
   }
}

/*void USART1_IRQHandler() {
   if (USART_GetFlagStatus(USART1, USART_FLAG_TC) == SET) {
      USART_ClearITPendingBit(USART1, USART_IT_TC);
      USART_ClearFlag(USART1, USART_FLAG_TC);
   }
}*/

void I2C1_IRQHandler() {
   i2c1_isr_register_g |= I2C1->ISR;
   SHT21_Measurement_TypeDef current_measurement = sht21_measurements_queue_g[sht21_measurements_queue_index_g];

   if (I2C_GetFlagStatus(I2C1, I2C_FLAG_TXIS)) {
      /* I2C_FLAG_TXIS. This bit is set by hardware when the I2C_TXDR register is empty and the data to be
       * transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be
       * sent is written in the I2C_TXDR register.
       */
      if (current_measurement.status & SHT21_WRITE_SENT_FLAG) {
         sht21_measurements_queue_g[sht21_measurements_queue_index_g].status &= (unsigned char) (~SHT21_WRITE_SENT_FLAG);
         I2C_SendData(I2C1, current_measurement.command);
         sht21_measurements_queue_g[sht21_measurements_queue_index_g].status |= (unsigned char) (SHT21_COMMAND_SENT_FLAG);
         sht21_measurement_countdown_counter_g = TIMER3_100MS;
      }
   } else if (I2C_GetFlagStatus(I2C1, I2C_FLAG_RXNE)) {
      unsigned short received_data = I2C_ReceiveData(I2C1);

      if (current_measurement.status & SHT21_READ_SENT_FLAG) {
         if (current_measurement.received_bytes == 2) {
            sht21_measurements_queue_g[sht21_measurements_queue_index_g].received_data_checksum = (unsigned char) received_data;

            sht21_measurements_queue_g[sht21_measurements_queue_index_g].status &= (unsigned char) (~SHT21_READ_SENT_FLAG);
            sht21_measurements_queue_g[sht21_measurements_queue_index_g].status |= (unsigned char) (SHT21_DATA_READ_FLAG);
         } else {
            unsigned short current_data = current_measurement.received_data;

            current_data <<= (current_measurement.received_bytes * 8);
            current_data |= received_data;
            sht21_measurements_queue_g[sht21_measurements_queue_index_g].received_data = current_data;
         }

         sht21_measurements_queue_g[sht21_measurements_queue_index_g].received_bytes++;
      }
   } else if (I2C_GetFlagStatus(I2C1, I2C_FLAG_STOPF)) {
      /* This flag is set by hardware when a Stop condition is detected on the bus and the peripheral is involved in this transfer:
       * – either as a master, provided that the STOP condition is generated by the peripheral.
       * – or as a slave, provided that the peripheral has been addressed previously during this transfer.
       */
      I2C_ClearITPendingBit(I2C1, I2C_IT_STOPF);

      sht21_measurements_queue_g[sht21_measurements_queue_index_g].status |= SHT21_STOP_RECEIVED_FLAG;
      sht21_measurements_queue_g[sht21_measurements_queue_index_g].received_stops++;
   } else if (I2C_GetFlagStatus(I2C1, I2C_FLAG_NACKF)) {
      // This flag is set by hardware when a NACK is received after a byte transmission.
      I2C_ClearITPendingBit(I2C1, I2C_IT_NACKF);
   } else if (I2C_GetFlagStatus(I2C1, I2C_FLAG_TC)) {
      // This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred.
      // It is cleared by software when START bit or STOP bit is set.
      I2C_ClearITPendingBit(I2C1, I2C_IT_TC);
   }
}

int main() {
   RCC_APB2PeriphClockCmd(RCC_APB2Periph_DBGMCU, ENABLE);
   iwdg_config();
   clock_config();
   pins_config();
   dma_config();
   usart_config();
   adc_config();
   timer3_confing();
   timer14_confing();
   i2c_config();

   IWDG_ReloadCounter();

   init_sht21_measurements_queue();

   while (1) {
      IWDG_ReloadCounter();

      if (measurements_period_counter_g >= TIMER14_10S) {
         measurements_period_counter_g = 0;

         set_flag(&general_flags_g, SHT21_MEASUREMENT_IS_IN_PROGRESS_FLAG);
         sht21_measurements_queue_index_g = 0;
         ADC_StartOfConversion(ADC1);
      }

      if (read_flag(general_flags_g, SHT21_MEASUREMENT_IS_IN_PROGRESS_FLAG)) {
         SHT21_Measurement_TypeDef current_measurement = sht21_measurements_queue_g[sht21_measurements_queue_index_g];

         if (current_measurement.status == 0) {
            sht21_measurements_queue_g[sht21_measurements_queue_index_g].status |= (unsigned char) (SHT21_WRITE_SENT_FLAG);
            send_I2C_command(current_measurement.address);
         } else if ((current_measurement.status & SHT21_COMMAND_SENT_FLAG) && sht21_measurement_countdown_counter_g == 0) {
            sht21_measurements_queue_g[sht21_measurements_queue_index_g].status &= (unsigned char) (~SHT21_COMMAND_SENT_FLAG);
            read_I2C(current_measurement.address);
            sht21_measurements_queue_g[sht21_measurements_queue_index_g].status |= (unsigned char) (SHT21_READ_SENT_FLAG);
         } else if (current_measurement.status & SHT21_DATA_READ_FLAG) {
            if (current_measurement.command == (unsigned char) (TRIGGER_T_MEASUREMENT)) {
               temperature_g = sht21_calculate_temperature(current_measurement.received_data, current_measurement.received_data_checksum);
            } else if (current_measurement.command == (unsigned char) (TRIGGER_RH_MEASUREMENT)) {
               humidity_g = sht21_calculate_humidity(current_measurement.received_data, current_measurement.received_data_checksum);
            }

            sht21_measure_next_parameter();

            if (!read_flag(general_flags_g, SHT21_MEASUREMENT_IS_IN_PROGRESS_FLAG)) {
               // All measurements of SHT21 have been completed

               char *temperature = float_to_string(temperature_g, 2);
               char *humidity = float_to_string(humidity_g, 2);
               char *light = num_to_string(adc_dma_converted_data_g);
               char *parameters[] = {temperature, humidity, light, NULL};
               result_to_send_g = set_string_parameters(SEND_ALL_MEASURED_PARAMS_JSON, parameters);

               free(temperature);
               free(humidity);
               free(light);

               send_usard_data(result_to_send_g);

               if (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_5)) {
                  GPIO_WriteBit(GPIOA, GPIO_Pin_5, Bit_RESET);
               } else {
                  GPIO_WriteBit(GPIOA, GPIO_Pin_5, Bit_SET);
               }
            }
         } else if (current_measurement.status & SHT21_STOP_RECEIVED_FLAG) {
            sht21_measurements_queue_g[sht21_measurements_queue_index_g].status &= (unsigned char) (~SHT21_STOP_RECEIVED_FLAG);

            if (current_measurement.status & SHT21_READ_SENT_FLAG) {
               if (current_measurement.received_stops < 4) {
                  sht21_measurements_queue_g[sht21_measurements_queue_index_g].status |= (unsigned char) (SHT21_REREAD_FLAG);
                  sht21_measurements_queue_g[sht21_measurements_queue_index_g].received_bytes = 0;
                  sht21_measurement_countdown_counter_g = TIMER3_100MS;
               } else {
                  sht21_measure_next_parameter();
               }
            }
         } else if ((current_measurement.status & SHT21_REREAD_FLAG) && sht21_measurement_countdown_counter_g == 0) {
            sht21_measurements_queue_g[sht21_measurements_queue_index_g].status &= (unsigned char) (~SHT21_REREAD_FLAG);
            read_I2C(current_measurement.address);
         }
      } else if (read_flag(general_flags_g, USART_TRANSFER_COMPLETE_FLAG)) {
         reset_flag(&general_flags_g, USART_TRANSFER_COMPLETE_FLAG);
         free(result_to_send_g);
      }
   }
}

float sht21_calculate_temperature(unsigned short data, unsigned char checksum) {
   if (checksum != sht21_calculate_crc(data)) {
      return SHT21_CRC_ERROR;
   }
   if (data & 0x2) {
      return SHT21_NOT_TEMPERATURE_MEASUREMENT_ERROR;
   }

   float temperature = (float) (data & ((unsigned short) 0x3FFFC));
   return 175.72 * temperature / 0xFFFF - 46.85;
}

float sht21_calculate_humidity(unsigned short data, unsigned char checksum) {
   if (checksum != sht21_calculate_crc(data)) {
      return SHT21_CRC_ERROR;
   }
   if (!(data & 0x2)) {
      return SHT21_NOT_HUMIDITY_MEASUREMENT_ERROR;
   }

   float humidity = (float) (data & ((unsigned short) 0x3FFFC));
   return 125 * humidity / 0xFFFF - 6;
}

unsigned char sht21_calculate_crc(unsigned short data) {
  for (unsigned char bit = 0; bit < 16; bit++) {
    if (data & 0x8000) {
       data = (data << 1) ^ SHT21_CRC8_POLYNOMIAL;
    } else {
       data <<= 1;
    }
  }
  return (unsigned char) (data >>= 8);
}

void sht21_measure_next_parameter() {
   sht21_measurements_queue_index_g++;

   if (sht21_measurements_queue_index_g >= 2) {
      sht21_measurements_queue_index_g = 0;
      init_sht21_measurements_queue();
      reset_flag(&general_flags_g, SHT21_MEASUREMENT_IS_IN_PROGRESS_FLAG);
   }
}

void init_sht21_measurements_queue() {
   for (unsigned char i = 0; i < 2; i++) {
      sht21_measurements_queue_g[i].address = SHT21_ADDRESS;
      sht21_measurements_queue_g[i].status = 0;
      sht21_measurements_queue_g[i].received_data = 0;
      sht21_measurements_queue_g[i].received_data_checksum = 0;
      sht21_measurements_queue_g[i].received_bytes = 0;
      sht21_measurements_queue_g[i].received_stops = 0;

      if (i == 0) {
         sht21_measurements_queue_g[i].command = TRIGGER_T_MEASUREMENT;
      } else {
         sht21_measurements_queue_g[i].command = TRIGGER_RH_MEASUREMENT;
      }
   }
}

void send_I2C_command(unsigned char address) {
   i2c1_isr_register_g = 0;

   I2C_SlaveAddressConfig(I2C1, address);
   I2C_MasterRequestConfig(I2C1, I2C_Direction_Transmitter);
   I2C_NumberOfBytesConfig(I2C1, 1);
   I2C_GenerateSTART(I2C1, ENABLE);
}

void read_I2C(unsigned char address) {
   i2c1_isr_register_g = 0;

   I2C_SlaveAddressConfig(I2C1, address);
   I2C_MasterRequestConfig(I2C1, I2C_Direction_Receiver);
   I2C_NumberOfBytesConfig(I2C1, 3);
   I2C_GenerateSTART(I2C1, ENABLE);
}

void iwdg_config() {
   DBGMCU_APB1PeriphConfig(DBGMCU_IWDG_STOP, ENABLE);

   IWDG_Enable();
   IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
   IWDG_SetPrescaler(IWDG_Prescaler_256);
   IWDG_SetReload(156); // 1 second
   while (IWDG_GetFlagStatus(IWDG_FLAG_PVU) == SET);
   while (IWDG_GetFlagStatus(IWDG_FLAG_RVU) == SET);
}

void clock_config() {
   RCC_HCLKConfig(RCC_SYSCLK_Div1); // default actually
   RCC_PCLKConfig(RCC_HCLK_Div1); // default actually

   RCC_I2CCLKConfig(RCC_I2C1CLK_HSI);
   RCC_USARTCLKConfig(RCC_USART1CLK_HSI);
}

void init_pin_as_output(GPIO_TypeDef* GPIOx, unsigned int pin) {
   GPIO_InitTypeDef GPIO_InitType;
   GPIO_InitType.GPIO_Pin = pin;
   GPIO_InitType.GPIO_Mode = GPIO_Mode_OUT;
   GPIO_InitType.GPIO_Speed = GPIO_Speed_Level_1;
   GPIO_InitType.GPIO_PuPd = GPIO_PuPd_NOPULL;
   GPIO_InitType.GPIO_OType = GPIO_OType_PP;
   GPIO_Init(GPIOx, &GPIO_InitType);
}

void pins_config() {
   // Connect BOOT0 directly to ground, RESET to VDD with a resistor

   RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA | RCC_AHBPeriph_GPIOB, ENABLE);

   GPIO_InitTypeDef ports_default_config;
   ports_default_config.GPIO_Pin = GPIO_Pin_All & ~(GPIO_Pin_13 | GPIO_Pin_14); // PA13, PA14 - Debugger pins
   ports_default_config.GPIO_Mode = GPIO_Mode_IN;
   ports_default_config.GPIO_Speed = GPIO_Speed_Level_1; // 2 MHz
   ports_default_config.GPIO_PuPd = GPIO_PuPd_UP;
   GPIO_Init(GPIOA, &ports_default_config);

   ports_default_config.GPIO_Pin = GPIO_Pin_All;
   GPIO_Init(GPIOB, &ports_default_config);

   GPIO_Init(GPIOF, &ports_default_config);

   GPIO_InitTypeDef led_pin_config;
   led_pin_config.GPIO_Pin = GPIO_Pin_5;
   led_pin_config.GPIO_Mode = GPIO_Mode_OUT;
   led_pin_config.GPIO_Speed = GPIO_Speed_Level_1;
   led_pin_config.GPIO_PuPd = GPIO_PuPd_DOWN;
   led_pin_config.GPIO_OType = GPIO_OType_PP;
   GPIO_Init(GPIOA, &led_pin_config);
   GPIO_WriteBit(GPIOA, GPIO_Pin_5, Bit_RESET);
}

/**
 * USART frame time Tfr = (1 / USART_BAUD_RATE) * 10bits
 * Timer time to be sure the frame is ended Tt = 1.5 * Tfr
 */
void timer3_confing() {
   TIM_DeInit(TIM3);
   TIM_SetCounter(TIM3, 0);

   DBGMCU_APB1PeriphConfig(DBGMCU_TIM3_STOP, ENABLE);
   RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);

   TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
   TIM_TimeBaseStructure.TIM_Period = TIMER3_PERIOD_TICKS;
   TIM_TimeBaseStructure.TIM_Prescaler = 0;
   TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
   TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);

   NVIC_EnableIRQ(TIM3_IRQn);
   TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);

   TIM_Cmd(TIM3, ENABLE);
}

void timer14_confing() {
   TIM_DeInit(TIM14);
   TIM_SetCounter(TIM14, 0);

   DBGMCU_APB1PeriphConfig(DBGMCU_TIM14_STOP, ENABLE);
   RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM14, ENABLE);

   TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
   TIM_TimeBaseStructure.TIM_Period = TIMER14_PERIOD;
   TIM_TimeBaseStructure.TIM_Prescaler = TIMER14_PRESCALER;
   TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
   TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   TIM_TimeBaseInit(TIM14, &TIM_TimeBaseStructure);

   TIM_ClearITPendingBit(TIM14, TIM_IT_Update);
   NVIC_EnableIRQ(TIM14_IRQn);
   TIM_ITConfig(TIM14, TIM_IT_Update, ENABLE);

   TIM_Cmd(TIM14, ENABLE);
}

void i2c_config() {
   RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);

   GPIO_InitTypeDef GPIO_InitStructure;
   GPIO_InitStructure.GPIO_Pin = I2C_SCL_PIN | I2C_SDA_PIN;
   GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
   GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
   GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   GPIO_Init(I2C_PORT, &GPIO_InitStructure);

   GPIO_PinAFConfig(I2C_PORT, I2C_SCL_AF_PIN_SOURCE, GPIO_AF_4);
   GPIO_PinAFConfig(I2C_PORT, I2C_SDA_AF_PIN_SOURCE, GPIO_AF_4);

   I2C_InitTypeDef I2C_InitStructure;
   I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
   I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   I2C_InitStructure.I2C_AnalogFilter = I2C_AnalogFilter_Enable;
   I2C_InitStructure.I2C_DigitalFilter = 0;
   I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
   I2C_InitStructure.I2C_OwnAddress1 = 0x4;
   I2C_InitStructure.I2C_Timing = 0x100F8CFF;
   I2C_Init(I2C1, &I2C_InitStructure);

   I2C_ReloadCmd(I2C1, DISABLE);
   I2C_AutoEndCmd(I2C1, ENABLE);

   NVIC_EnableIRQ(I2C1_IRQn);
   // The number of TXIS events during the transfer corresponds to the value programmed in NBYTES[7:0]
   I2C_ITConfig(I2C1, I2C_IT_TXI | I2C_IT_ERRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI, ENABLE);

   I2C_Cmd(I2C1, ENABLE);
}

void dma_config() {
   RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1 , ENABLE);

   // USART DMA config
   DMA_InitTypeDef usartDmaInitType;
   usartDmaInitType.DMA_PeripheralBaseAddr = USART1_TDR_ADDRESS;
   //usartDmaInitType.DMA_MemoryBaseAddr = (uint32_t) (&usart_data_to_be_transmitted_buffer_g);
   usartDmaInitType.DMA_DIR = DMA_DIR_PeripheralDST; // Specifies if the peripheral is the source or destination
   usartDmaInitType.DMA_BufferSize = 0;
   usartDmaInitType.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   usartDmaInitType.DMA_MemoryInc = DMA_MemoryInc_Enable; // DMA_MemoryInc_Enable if DMA_InitTypeDef.DMA_BufferSize > 1
   usartDmaInitType.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
   usartDmaInitType.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;
   usartDmaInitType.DMA_Mode = DMA_Mode_Normal;
   usartDmaInitType.DMA_Priority = DMA_Priority_Low;
   usartDmaInitType.DMA_M2M = DMA_M2M_Disable;
   DMA_Init(USART1_TX_DMA_CHANNEL, &usartDmaInitType);

   DMA_ITConfig(USART1_TX_DMA_CHANNEL, DMA_IT_TC, ENABLE);
   NVIC_SetPriority(USART1_IRQn, 10);
   NVIC_EnableIRQ(USART1_IRQn);
   DMA_Cmd(USART1_TX_DMA_CHANNEL, ENABLE);

   // ADC DMA config
   DMA_InitTypeDef adcDmaInitType;
   adcDmaInitType.DMA_PeripheralBaseAddr = ADC1_DR_ADDRESS;
   adcDmaInitType.DMA_MemoryBaseAddr = (uint32_t) (&adc_dma_converted_data_g);
   adcDmaInitType.DMA_DIR = DMA_DIR_PeripheralSRC;
   adcDmaInitType.DMA_BufferSize = 1;
   adcDmaInitType.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   adcDmaInitType.DMA_MemoryInc = DMA_MemoryInc_Disable; // DMA_MemoryInc_Enable if DMA_InitTypeDef.DMA_BufferSize > 1
   adcDmaInitType.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
   adcDmaInitType.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
   adcDmaInitType.DMA_Mode = DMA_Mode_Circular; // DMA_Mode_Circular in case of multiple channels
   adcDmaInitType.DMA_Priority = DMA_Priority_Low;
   adcDmaInitType.DMA_M2M = DMA_M2M_Disable;
   DMA_Init(ADC1_DMA_CHANNEL, &adcDmaInitType);

   DMA_ITConfig(ADC1_DMA_CHANNEL, DMA_IT_TC, ENABLE);
   NVIC_SetPriority(ADC1_IRQn, 30); // Higher than timers have
   NVIC_EnableIRQ(DMA1_Channel1_IRQn);
   DMA_Cmd(ADC1_DMA_CHANNEL, ENABLE);
}

void usart_config() {
   // For USART1
   GPIO_InitTypeDef usart_pins_config;
   usart_pins_config.GPIO_Pin = USART_TX_PIN;
   usart_pins_config.GPIO_PuPd = GPIO_PuPd_NOPULL;
   usart_pins_config.GPIO_Mode = GPIO_Mode_AF;
   usart_pins_config.GPIO_OType = GPIO_OType_PP; // GPIO_OType_OD for USART RX
   GPIO_Init(USART_TX_PORT, &usart_pins_config);

   GPIO_PinAFConfig(USART_TX_PORT, USART_TX_AF_PIN_SOURCE, GPIO_AF_1);

   RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);

   USART_OverSampling8Cmd(USART1, DISABLE);

   USART_InitTypeDef USART_InitStructure;
   USART_InitStructure.USART_BaudRate = USART_BAUD_RATE;
   USART_InitStructure.USART_WordLength = USART_WordLength_8b;
   USART_InitStructure.USART_StopBits = USART_StopBits_1;
   USART_InitStructure.USART_Parity = USART_Parity_No;
   USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   USART_InitStructure.USART_Mode = USART_Mode_Tx;
   USART_Init(USART1, &USART_InitStructure);

   NVIC_SetPriority(DMA1_Channel2_3_IRQn, 11);
   NVIC_EnableIRQ(DMA1_Channel2_3_IRQn);

   USART_DMACmd(USART1, USART_DMAReq_Tx, ENABLE);

   USART_Cmd(USART1, ENABLE);
}

void adc_config() {
   RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);

   GPIO_InitTypeDef gpioInitType;
   gpioInitType.GPIO_Pin = LIGHT_SENSOR_PIN;
   gpioInitType.GPIO_PuPd = GPIO_PuPd_NOPULL;
   gpioInitType.GPIO_Mode = GPIO_Mode_AN;
   gpioInitType.GPIO_Speed = GPIO_Speed_Level_1; // Low 2 MHz
   GPIO_Init(LIGHT_SENSOR_PORT, &gpioInitType);

   ADC_InitTypeDef adcInitType;
   adcInitType.ADC_ContinuousConvMode = ENABLE;
   adcInitType.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_Rising;
   ADC_StructInit(&adcInitType);
   ADC_Init(ADC1, &adcInitType);

   ADC_ClockModeConfig(ADC1, ADC_ClockMode_SynClkDiv4);

   ADC_DMARequestModeConfig(ADC1, ADC_DMAMode_Circular); // ADC_DMAMode_Circular in case of multiple channels
   ADC_DMACmd(ADC1, ENABLE);

   ADC_ChannelConfig(ADC1, LIGHT_SENSOR_ADC_CHANNEL, ADC_SampleTime_41_5Cycles);

   ADC_AutoPowerOffCmd(ADC1, ENABLE);

   ADC_GetCalibrationFactor(ADC1);

   ADC_Cmd(ADC1, ENABLE);
   while(!ADC_GetFlagStatus(ADC1, ADC_FLAG_ADEN));
}

void send_usard_data(char *string) {
   reset_flag(&general_flags_g, USART_TRANSFER_COMPLETE_FLAG);
   DMA_Cmd(USART1_TX_DMA_CHANNEL, DISABLE);
   unsigned short bytes_to_send = get_string_length(string);

   if (bytes_to_send == 0) {
      return;
   }

   DMA_SetCurrDataCounter(USART1_TX_DMA_CHANNEL, bytes_to_send);
   USART1_TX_DMA_CHANNEL->CMAR = (unsigned int) string;
   USART_ClearFlag(USART1, USART_FLAG_TC);
   DMA_Cmd(USART1_TX_DMA_CHANNEL, ENABLE);
}
